<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mysql基础]]></title>
    <url>%2F2018%2F11%2F19%2Fmysql2%2F</url>
    <content type="text"><![CDATA[MySQL 基础常用命令]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 基础 2]]></title>
    <url>%2F2018%2F11%2F08%2Fpython2%2F</url>
    <content type="text"><![CDATA[list 和 tuplelistPython内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。 123&gt;&gt;&gt; classmates = ['Michael', 'Bob', 'Tracy']&gt;&gt;&gt; classmates['Michael', 'Bob', 'Tracy'] 变量classmates就是一个list。用len()函数可以获得list元素的个数 list是一个可变的有序表，所以，可以往list中追加元素到末尾： 123&gt;&gt;&gt; classmates.append('Adam')&gt;&gt;&gt; classmates['Michael', 'Bob', 'Tracy', 'Adam'] 也可以把元素插入到指定的位置，比如索引号为1的位置： 123&gt;&gt;&gt; classmates.insert(1, 'Jack')&gt;&gt;&gt; classmates['Michael', 'Jack', 'Bob', 'Tracy', 'Adam'] 要删除指定位置的元素，用pop(i)方法，其中i是索引位置： 1234&gt;&gt;&gt; classmates.pop(1)'Jack'&gt;&gt;&gt; classmates['Michael', 'Bob', 'Tracy'] tuple另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改， 条件判断if条件判断12345678if &lt;条件判断1&gt;: &lt;执行1&gt;elif &lt;条件判断2&gt;: &lt;执行2&gt;elif &lt;条件判断3&gt;: &lt;执行3&gt;else: &lt;执行4&gt; 1234567age = 3if age &gt;= 18: print('adult')elif age &gt;= 6: print('teenager')else: print('kid') 循环for…in循环1234sum = 0for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]: sum = sum + xprint(sum) dict和setdictPython内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。 123&gt;&gt;&gt; d = &#123;'Michael': 95, 'Bob': 75, 'Tracy': 85&#125;&gt;&gt;&gt; d['Michael']95 setset和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。 123&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s&#123;1, 2, 3&#125; 函数切片123&gt;&gt;&gt; L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']&gt;&gt;&gt; L[0:3]['Michael', 'Sarah', 'Tracy'] L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。 L[:10] 前十个数]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 基础之数据类型和变量]]></title>
    <url>%2F2018%2F11%2F08%2Fpython1%2F</url>
    <content type="text"><![CDATA[数据类型和变量数据类型整数，浮点数，字符串 , 布尔值字符串字符串是以单引号&#39;或双引号&quot;括起来的任意文本，比如&#39;abc&#39;，&quot;xyz&quot;等等 转义字符\可以转义很多字符，比如\n表示换行，\t表示制表符，字符\本身也要转义，所以\\表示的字符就是\ 1'I\'m \"OK\"!' 布尔值布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来： 12345678&gt;&gt;&gt; TrueTrue&gt;&gt;&gt; FalseFalse&gt;&gt;&gt; 3 &gt; 2True&gt;&gt;&gt; 3 &gt; 5False 布尔值可以用and、or和not运算。 and运算是与运算，只有所有都为True，and运算结果才是True： 12345678&gt;&gt;&gt; True and TrueTrue&gt;&gt;&gt; True and FalseFalse&gt;&gt;&gt; False and FalseFalse&gt;&gt;&gt; 5 &gt; 3 and 3 &gt; 1True or运算是或运算，只要其中有一个为True，or运算结果就是True： 12345678&gt;&gt;&gt; True or TrueTrue&gt;&gt;&gt; True or FalseTrue&gt;&gt;&gt; False or FalseFalse&gt;&gt;&gt; 5 &gt; 3 or 1 &gt; 3True not运算是非运算，它是一个单目运算符，把True变成False，False变成True： 123456&gt;&gt;&gt; not TrueFalse&gt;&gt;&gt; not FalseTrue&gt;&gt;&gt; not 1 &gt; 2True 空值空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。 变量变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。 变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头，]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown语法]]></title>
    <url>%2F2018%2F11%2F05%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[markdown基本语法标题(12345678```markdown# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 (1234567891011121314## 字体(```)```markdown**这是加粗的文字***这是倾斜的文字****这是斜体加粗的文字***~~这是加删除线的文字~~ (1234567891011## 引用(```)```markdown&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 (12345678910## 图片(```)```html![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 (123456789101112131415161718192021222324252627## 列表嵌套### **上一级和下一级之间敲三个空格即可**一级无序列表内容- 二级无序列表内容- 二级无序列表内容- 二级无序列表内容## 表格```markdown表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 代码单行代码‘create database hero;’ 代码块 123456```jsfunction fun()&#123; echo "这是一句非常牛逼的代码"; &#125; fun();流程图123456789​```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp; 123456## 超链接```html[超链接名](超链接地址 "超链接title")title可加可不加 百度]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java Io]]></title>
    <url>%2F2018%2F10%2F31%2FjavaIo%2F</url>
    <content type="text"><![CDATA[Java Io]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA快捷键]]></title>
    <url>%2F2018%2F10%2F05%2FIDEA%2F</url>
    <content type="text"><![CDATA[#IDEA快捷键Ctrl+Shift + Enter，语句完成 “！”，否定完成，输入表达式时按 “！”键 Ctrl+E，最近的文件 Ctrl+Shift+E，最近更改的文件 Shift+Click，可以关闭文件 Ctrl+[ OR ]，可以跑到大括号的开头与结尾 Ctrl+F12，可以显示当前文件的结构 Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择 Ctrl+N，可以快速打开类 Ctrl+Shift+N，可以快速打开文件 Alt+Q，可以看到当前方法的声明 Ctrl+P，可以显示参数信息 Ctrl+Shift+Insert，可以选择剪贴板内容并插入 Alt+Insert，可以生成构造器/Getter/Setter等 Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义 Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch Ctrl+Enter，导入包，自动修正 Ctrl+Alt+L，格式化代码 Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作 Ctrl+Alt+O，优化导入的类和包 Ctrl+R，替换文本 Ctrl+F，查找文本 Ctrl+Shift+Space，自动补全代码 Ctrl+空格，代码提示（与系统输入法快捷键冲突） Ctrl+Shift+Alt+N，查找类中的方法或变量 Alt+Shift+C，最近的更改 Alt+Shift+Up/Down，上/下移一行 Shift+F6，重构 – 重命名 Ctrl+X，删除行 Ctrl+D，复制行 Ctrl+/或Ctrl+Shift+/，注释（//或者/**/） Ctrl+J，自动代码（例如：serr） Ctrl+Alt+J，用动态模板环绕 Ctrl+H，显示类结构图（类的继承层次） Ctrl+Q，显示注释文档 Alt+F1，查找代码所在位置 Alt+1，快速打开或隐藏工程面板 Ctrl+Alt+left/right，返回至上次浏览的位置 Alt+left/right，切换代码视图 Alt+Up/Down，在方法间快速移动定位 Ctrl+Shift+Up/Down，向上/下移动语句 F2 或 Shift+F2，高亮错误或警告快速定位 Tab，代码标签输入完成后，按 Tab，生成代码 Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失 Alt+F3，逐个往下查找相同文本，并高亮显示 Ctrl+Up/Down，光标中转到第一行或最后一行下 Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处） Ctrl+Alt+B，跳转到方法实现处 Ctrl+Shift+Backspace，跳转到上次编辑的地方 Ctrl+O，重写方法 Ctrl+Alt+Space，类名自动完成 Ctrl+Alt+Up/Down，快速跳转搜索结果 Ctrl+Shift+J，整合两行 Alt+F8，计算变量值 Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本 Ctrl+Alt+Shift+V，简单粘贴 Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口 F12，把焦点从编辑器移到最近使用的工具窗口 Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器 Ctrl+W，可以选择单词继而语句继而行继而函数 Ctrl+Shift+W，取消选择光标所在词 Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置 Ctrl+I，实现方法 Ctrl+Shift+U，大小写转化 Ctrl+Y，删除当前行 Shift+Enter，向下插入新行 psvm/sout，main/System.out.println(); Ctrl+J，查看更多 Ctrl+Shift+F，全局查找 Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找 Ctrl+Shift+S，高级搜索 Ctrl+U，转到父类 Ctrl+Alt+S，打开设置对话框 Alt+Shift+Inert，开启/关闭列选择模式 Ctrl+Alt+Shift+S，打开当前项目/模块属性 Ctrl+G，定位行 Alt+Home，跳转到导航栏 Ctrl+Enter，上插一行 Ctrl+Backspace，按单词删除 Ctrl+”+/-”，当前方法展开、折叠 Ctrl+Shift+”+/-”，全部展开、折叠 【调试部分、编译】 Ctrl+F2，停止 Alt+Shift+F9，选择 Debug Alt+Shift+F10，选择 Run Ctrl+Shift+F9，编译 Ctrl+Shift+F10，运行 Ctrl+Shift+F8，查看断点 F8，步过 F7，步入 Shift+F7，智能步入 Shift+F8，步出 Alt+Shift+F8，强制步过 Alt+Shift+F7，强制步入 Alt+F9，运行至光标处 Ctrl+Alt+F9，强制运行至光标处 F9，恢复程序 Alt+F10，定位到断点 Ctrl+F8，切换行断点 Ctrl+F9，生成项目 Alt+1，项目 Alt+2，收藏 Alt+6，TODO Alt+7，结构 Ctrl+Shift+C，复制路径 Ctrl+Alt+Shift+C，复制引用，必须选择类名 Ctrl+Alt+Y，同步 Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单） Shift+F12，还原默认布局 Ctrl+Shift+F12，隐藏/恢复所有窗口 Ctrl+F4，关闭 Ctrl+Shift+F4，关闭活动选项卡 Ctrl+Tab，转到下一个拆分器 Ctrl+Shift+Tab，转到上一个拆分器 【重构】 Ctrl+Alt+Shift+T，弹出重构菜单 Shift+F6，重命名 F6，移动 F5，复制 Alt+Delete，安全删除 Ctrl+Alt+N，内联 【查找】 Ctrl+F，查找 Ctrl+R，替换 F3，查找下一个 Shift+F3，查找上一个 Ctrl+Shift+F，在路径中查找 Ctrl+Shift+R，在路径中替换 Ctrl+Shift+S，搜索结构 Ctrl+Shift+M，替换结构 Alt+F7，查找用法 Ctrl+Alt+F7，显示用法 Ctrl+F7，在文件中查找用法 Ctrl+Shift+F7，在文件中高亮显示用法]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql优化]]></title>
    <url>%2F2018%2F09%2F30%2Fmysql%2F</url>
    <content type="text"><![CDATA[MySQL优化步（InnoDB）优化的优先级- 数据库结构设计 - SQL语句 - 数据库存储引擎和选择和参数配置 - 系统选择及优化 - 硬件升级 图书 MySQL必知必会 - 高性能MySQL - 深入浅出MySQL - MySQL排错指南 - MySQL管理之道-性能高估、高可用和监控（第一版） - MySQL管理之道-性能高估、高可用和监控（第二版） - MySQL技术内幕 -– 安装向导中的选项安装过程中的选择 -– 调试方法- show status：提供服务器状态信息 - show engine innodb status 查看innodb引擎的服务器状况 - show variables - EXPLAIN - show profile - performance_schema - show processlist - sql_no_cache - slow_query_log show statusshow [session|global] status \1234567891011121314151617181920\- session: 当前连接，默认为session\- global: 自数据库上次启动至今### 常用\- Connections: 试图连接MySQL服务器的次数\- Uptime:服务器工作时间\- Slow_queries:慢查询的次数\ show status like ‘Com_%’ /表示语句执行次数/ \1234567891011121314\#### show variables\#### EXPLAIN\ mysql&gt; explain select * from table_name; +—-+————-+————+——+—————+——+———+——+——+——-+ | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra | +—-+————-+————+——+—————+——+———+——+——+——-+ | 1 | SIMPLE | table_name | ALL | NULL | NULL | NULL | NULL | 1 | NULL | +—-+————-+————+——+—————+——+———+——+——+——-+ 1 row in set (0.00 sec) \123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384| 字段 | 说明|| :------ |:------|| id |表示查询中执行select子句或操作表的顺序 || select_type |查询中每个select子句的类型 || table |输出结果集的表| | type |表示MySQL在表中找到的所需行的方式，或者叫访问类型|| possible_keys |表示查询时可能使用的索引|| key |表示实际使用的索引，若没有使用索引，显示为NULL|| key_len |使用到索引字段的字节数（长度）|| ref |表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值|| rows |扫描行的数量 || Extra |包含不适合在其他列中显示但十分重要的额外信息|\##### id\1. id相同，执行顺序由上至下\1. 如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行\1. id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行\##### select_type| 字段 | 说明|| :------ |:------|| SIMPLE |简单的SELECT语句（没有使用 union 或者 子查询） || PRIMARY |查询中若包含任何复杂的子部分,最外层的select被标记为PRIMARY || UNION |在一个UNION语句中第二或之后的SELECT语句| | DEPENDENT UNION |在一个UNION语句中第二或之后的SELECT语句，取决于外层的查询|| UNION RESULT |UNION的结果集|| SUBQUERY |子查询中的第一个SELECT|| DEPENDENT SUBQUERY |子查询中的第一个SELECT，取决于外面的查询|| DERIVED |派生表的SELECT, FROM子句的子查询|| UNCACHEABLE SUBQUERY |不能将结果缓存的子查询，必须重新计算外部查询的每一行|| UNCACHEABLE UNION |在一个UNION中第二或之后的SELECT查询属于UNCACHEABLE SUBQUERY（请看UNCACHEABLE SUBQUERY)|说明：\- DEPENDENT：典型代表就是使用了相关子查询。（相关子查询：子查询里包含了一个同时在子查询里，又在外部查询的表的查询）\- DEPENDENT SUBQUERY: 它不同于UNCACHEABLE SUBQUERY的求值。对于DEPENDENT SUBQUERY，子查询对于外部上下文里每一个集合中不同的变星值仅仅重新计算一次。而对于UNCACHEABLE SUBQUERY，子查询对于外部上下文里的每一行都会重新计算一次.\##### type常用的类型有（从左到右，性能从差到好）：\ +—–+——-+——-+——+——–+—————-+——+ | ALL | index | range | ref | eq_ref | const, system | NULL | +—–+——-+——-+——+——–+—————-+——+ \123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144| 字段 | 说明|| :------ |:------|| ALL |全表扫描，MySQL遍历全表来找到匹配的行 || index |索引全扫描，MySQL遍历整个索引来查询匹配的行，index与ALL区别为index类型只遍历索引树。 || range |索引范围扫描，只检索给定范围的行，使用一个索引来选择行，常见于`&lt;、&lt;=、&gt;、&gt;=、between`等操作符。| | ref |使用非唯一索引扫描或唯一索引的前缀扫描，返回匹配某个单独值的记录行|| eq_ref |类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件|| const, system |当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量|| NULL |MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。|\##### explain extended和show warningsexplain 的extended 扩展能够在原本explain的基础上额外的提供一些查询优化的信息，这些信息可以通过MySQL的show warnings命令得到。[官方说明](http://dev.mysql.com/doc/refman/5.5/en/explain-output.html)\#### show profile使用`show profile`和 `show profiles`我们可以更清楚的了解SQL执行的过程。\- 执行过程 \1. `set profiling = 1` # 打开profiling \1. 执行查询 \1. `show profiles;` \1. 通过`show profile for query N`语句能够看到执行过程中线程的每个状态和消耗的时间。\#### performance_schema\- 可以代替show profile\- 5.5最好不用，性能有问题， 5.6以后建议开启\#### no_sql_cache`SQL_NO_CACHE`的真正作用是禁止缓存查询结果，但并不意味着cache不作为结果返回给query。使用方法：`select no_sql_cache ...`\#### show full processlist可以用语句`SELECT * FROM information_schema.processlist`代替`show full processlist`并可以过虑想要的数据。| 字段 | 说明|| :------ |:------|| id| 不用说了吧，一个标识，你要kill一个语句的时候很有用。|| user| 显示单前用户，如果不是root，这个命令就只显示你权限范围内的sql语句。|| host| 显示这个语句是从哪个ip的哪个端口上发出的。呵呵，可以用来追踪出问题语句的用户。|| db| 显示这个进程目前连接的是哪个数据库。command列，显示当前连接的执行的命令，一般就是休眠（sleep），查询（query），连接（connect）。|| time| 此这个状态持续的时间，单位是秒。|| state| 显示使用当前连接的sql语句的状态，很重要的列，后续会有所有的状态的描述，请注意，state只是语句执行中的某一个状态，一个sql语句，已查询为例，可能需要经过copying to tmp table，Sorting result，Sending data等状态才可以完成。|| info| 显示这个sql语句，因为长度有限，所以长的sql语句就显示不全，但是一个判断问题语句的重要依据。|\#### slow_query_log使用`show variables like '%slow%'; `查看是否启用慢查询。| 参数 | 说明|| :------ |:------||slow_query_log |指定是否开启慢查询日志 ||long_query_time |设定慢查询的阀值，超出次设定值的SQL即被记录到慢查询日志，缺省值为10s ||slow_query_log_file|指定慢日志文件存放位置，可以为空，系统会给一个缺省的文件host_name-slow.log ||min_examined_row_limit|：查询检查返回少于该参数指定行的SQL不被记录到慢查询日志 ||log_queries_not_using_indexes| 不使用索引的慢查询日志是否记录到索引| 打开慢查询配置\ slow_query_log = 1 slow_query_log_file long_query_time = 2 log_queries_not_using_indexes log_slow_queries=/data/3306/slow-log.log \123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214\##### 慢查询日志分析工具\- mysqldumpslow \- `mysqldumpslow -s -r -t 10 slow-mysql.log`​ \- `-s order (c,t,1,r,at,al,ar)` 指定按哪种排序方式输出结果​ \- `-t top` 指定取前几条作为结束输出\- pt-query-digest \- `pt-query-digest --explain h=127.0.0.1,u=root, p=password slow-mysql.log`\---\### 优化数据库（最重要）\#### 目的\- 减少数据冗余\- 尽量避免数据维护中出现插入、更新、删除异常\- 节约数据存储空间\- 提高查询效率\#### 数据库设计步骤\- 需求分析：全面了解产品的存储需求\- 逻辑设计：设计数据的逻辑存储结构，数据实体之间的逻辑关系，解决数据冗余和数据维护异常\- 物理设计：根据数据库特点进行表结构设计（关系型数据库、非关系型数据库、存储引擎）\- 维护优化：根据实际情况对索引、存储结构等进行优化\#### 范式遵循三范式就可以设计出符合需求的数据库结构，符合，不是最优的。\- 1NF： \- 数据库表中的字段都是单一属性的，不可再分。 \- 单一属性的列是由基本的数据类型所构成的 \- 设计出来的表都是简单的二维表\- 2NF：首先是 1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。\- 3NF：首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。 在设计数据库中要最大程序的遵守三范式，特别是对于OLTP型的系统。注意：三范式最大的问题在于查询时通常需要Join很多表，而这会导致查询效率很低，所以有时候基于性能考虑，我们需要有意违反三范式，适度的做冗余。最常见的反范式化的数据的方法是复制或者缓存，在不同的表中存储相同的特定列，使用触发器更新缓存值。另一个从父表冗余一些数据到的理由是排序的需要。通过触发器\#### 表设计\1. 更小的通常更好，一般情况下，应该尽量使用可以正确存储数据的最小数据类型。\1. 简单的数据类型，简单数据类型通常需要更好的CPU周期。\1. 尽量避免使用NULL，通常情况下最好指定列为NOT NULL，除非直接的城崾存储NUL值。注意：把可为NULL的列改为NOT NULL带来的恨不能提升比较小，没有必要首先在现有的schema中查找并修改掉这种情况。但是，如果计划在列上建索引，就应该尽量避免设计成可为NULL的列。\1. 避免太多的列。\1. 避免太多的关联，单个查询最好在12个表以内做关联，最多为61个表。不在数据库中存储图片、文件等所有字段均定义为NOT NULL ，除非你真的想存Null字段类型在满足需求条件下越小越好，使用UNSIGNED存储非负整数 ，实际使用时候存储负数场景不多使用TIMESTAMP存储时间使用varchar存储变长字符串 ，当然要注意varchar(M)里的M指的是字符数不是字节数；使用UNSIGNED INT存储IPv4 地址而不是CHAR(15) ，这种方式只能存储IPv4，存储不了IPv6使用DECIMAL存储精确浮点数，用float有的时候会有问题少用blob text\#### 字段类型的选取\##### 整数类型| 类型 | 存储空间 | 存储范围 | 存储范围数值 || :------|:------ |:------ |:------ || TINYINT | 8 | -2&lt;sup&gt;7&lt;/sup&gt; ~ 2&lt;sup&gt;7&lt;/sup&gt;-1| -128~127 | | SMALLINT | 16 | -2&lt;sup&gt;15&lt;/sup&gt; ~ 2&lt;sup&gt;15&lt;/sup&gt;-1| -32768~32767 || MEDIUMINT | 24 | -2&lt;sup&gt;23&lt;/sup&gt; ~ 2&lt;sup&gt;23&lt;/sup&gt;-1| -8388608~8388607 || INT | 32 | -2&lt;sup&gt;31&lt;/sup&gt; ~ 2&lt;sup&gt;31&lt;/sup&gt;-1| -2147483648~2147483647 || BIGINT | 64 | -2&lt;sup&gt;63&lt;/sup&gt; ~ 2&lt;sup&gt;63&lt;/sup&gt;-1| -9223372036854775808~9223372036854775807 |有符号和无符号使用相同的存储空间，并具有相同的功能，如果不允许负值，大致可以使正数的上限提高一倍。使用整数来存储IPV4，它实际是32位无符号整数，不是字符串，使用小数点将地址发成四段只是为了让人员阅读，通过INET_ATON()和INET_NTOA()函数进行转换。\##### 实数类型\1. 实数是带有小数部分的数字。\1. CPU支持直接原生浮点计划，CPU不支持DECIMAL的直接计算，MySQL服务器自身实现了DECIMAL的高精度计算，所以浮点运算明显更快。\1. MySQL使用DOUBLE作为内部浮点计算的类型。\1. 因为需要额外的空间和计算开销，所以应该尽量只在对小数进行精确论处时才使用DECIMAL（如存储财务数据），但在数据量比较大的时候，可以考虑使用BIGINT代替DECIMAL，需要存储的货币单位根据小数的倍数乘以相应的倍数即可。\##### 字符串类型在INNODB和MYISAM引擎下\1. 如果长度是明确的，请使用CHAR类型。\2. VARCHAR城崾发使用1个或两个额外的字节记录字符串的长度 。\3. 给VARCHAR分配真正需要的空间，VARCHAR(5)和VARCHAR(200)存‘hello’的空间开销是一样的，但是更长的列会消耗更多的内存，因为MySQL通常会分配固定大小的内存块来保存内部值。\4. 将Text或BLOB类型或超长 的字符类型的字段单独分配到一张表中，只做单表查询。\##### 日期和时间类型\1. MySQL能存储的最小时间粒度为秒（MariaDB支持微秒级别的时间类型）。\1. MySQL提供了两种相似的日期类型：DATETIME和TIMESTAMP，在某些场景下，会有差异。\1. 通应该尽量使用TIMESTAMP，比DATETIME空间效率更高。| 类型 | 存储空间 |范围 | 精度 | 时区 | 格式化|| :------|:------ |:------ |:------ |:------ |:------ || DATETIME | 8字节 |1001~9999年 | 秒| 无关 | YYYYMMDDHHMMSS || TIMESTAMP | 4字节 |1970-2038年| 秒 | 依赖 | 通过函数转换日期 |\1. 在默认情况下，如果插入时没有指定第一个TIMESTAMP列的值时，MySQL则设置这个列的值为当前时间，在更新一行记录时，MySQL默认也会更新第一个TIMESTAMP列的值。\1. TIMESTAMP列的默认值为NOT NULL。\1. 如果需要存储比秒更小粒度的日期和时间时，可以使用自己的存储格式，可以使用BIGINT类型存储微秒级别的时间戳，或都使用DOUBLE存储秒之后的小数部分。 last_update timestamp default now() on update now()12345678910111213141516171819202122232425262728\#### 标识列\1. 整数类型通常是标识列最好的选择，可以使用AUTO_INCREMENT。\1. 应该尽量避免使用字符串类型使为标识列，很消耗空间，并且比数字型慢，尤其在MYISAM表中，MYISAM默认对字符串使用压缩索引，这会导致查询慢得多（最多有6倍的恨不能下降）。\1. 如果存储UUID值，应该移除“-”符号；\1. UUID()生成的值有一定的顺序。\#### 缓存表或中间表\ /重建汇总表或缓存表/ drop table if exists my_summary_new, my_summary_old; create table my_summary_new like my_summary; rename table my_sumary to my_summary_old, my_summary_new to my_summary; \1234567891011121314151617181920\#### 物化视图(Materialized Views)Flexviews\#### 计数器表在更新时可能出现并发的问题，可以生成多行，每次随机选择一行进行更新。\ create table hit_counter( ​ slot tinyint unsigned not null primary key, ​ cnt int unsigned not null ) engine = innodb; update hit_counter set cnt = cnt + 1 where slot = rand() * 100; /每隔一段时间开始一个新的计数器/ create table daily_hit_counter( ​ day date not null, ​ slot tinyint unsigned not null, ​ cnt int unsigned not null, ​ primary key (day, slot) ) engine = innodb; insert into daily_hit_counter(day, slot, cnt) values(current_date, rand() * 100 ,1) on duplicate key update cnt = cnt + 1; \123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286\---\### SQL语句优化 \- 如何获取有性能问题的SQL \- 通过用户反馈获取存在性能问题的SQL \- 通过是查询日志获取存在性能问题的SQL \- 实时获取存在性能问题的SQL\- 查询速度为什么会慢 \1. 客户端发送请求给服务器 \1. 服务器检查是否可以在查询缓存中命中该SQL \1. 服务器商进行SQL解析，预处理，再由优化器生成对就的执行计划 \1. 根据执行计划，调用存储引擎API来查询数据库\- SQL语句的执行顺序\1. FORM: 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1\1. ON: 对虚表VT1进行ON筛选，只有那些符合&lt;join-condition&gt;的行才会被记录在虚表VT2中。\1. JOIN： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, rug from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为止。\1. WHERE： 对虚拟表VT3进行WHERE条件过滤。只有符合&lt;where-condition&gt;的记录才会被插入到虚拟表VT4中。\1. GROUP BY: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5.\1. CUBE | ROLLUP: 对表VT5进行cube或者rollup操作，产生表VT6.\1. HAVING： 对虚拟表VT6应用having过滤，只有符合&lt;having-condition&gt;的记录才会被 插入到虚拟表VT7中。\1. SELECT： 执行select操作，选择指定的列，插入到虚拟表VT8中。\1. DISTINCT： 对VT8中的记录进行去重。产生虚拟表VT9.\1. ORDER BY: 将虚拟表VT9中的记录按照&lt;order_by_list&gt;进行排序操作，产生虚拟表VT10.\1. LIMIT：取出指定行的记录，产生虚拟表VT11, 并将结果返回。优化not in 和 &lt;&gt; 查询前Query语句的优化思路和原则主要提现在以下几个方面：\1. 优化更需要优化的Query；\2. 定位优化对象的性能瓶颈；\3. 明确的优化目标；\4. 从Explain入手；\5. 多使用profile\6. 永远用小结果集驱动大的结果集；\7. 尽可能在索引中完成排序；\8. 只取出自己需要的Columns；\9. 仅仅使用最有效的过滤条件；10.尽可能避免复杂的Join和子查询；SQL 语句调优在应用层，通过pt工具和慢查询日志的配合，可以轻松地分辨出全表扫描的语句。基本原则避免全表扫描建立索引尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理尽量避免大事务操作，提高系统并发能力使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。尽量避免使用游标，因为游标的效率较差。雕虫小技关于where 后的条件应尽量避免在 where 子句中使用 != 或 &lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。应尽量避免在 where 子句中使用 or 来连接条件,可以考虑使用union 代替in 和 not in 也要慎用，对于连续的数值，能用 between 就不要用 in，exists 代替 in尽量避免在 where 子句中对字段进行表达式操作和函数操作关于数据类型尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为变长字段存储空间小，对于查询来说，在一个相对较小的字段内搜索效率显然要高些。最好不要给数据库留NULL，尽可能的使用 NOT NULL填充数据库.备注、描述、评论之类的可以设置为 NULL，其他的，最好不要使用NULL。任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。关于临时表避免频繁创建和删除临时表，以减少系统表资源的消耗。对于一次性事件， 最好使用导出表。在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。如果使用到了临时表，在最后将所有的临时表显式删除时，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。关于索引先应考虑在 where 及 order by 涉及的列上建立索引。在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件 时才能保证系统使用该索引， 否则该索引将不会 被使用， 并且应尽可能的让字段顺序与索引顺序相一致。索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert和update 的效率，因为 insert 或 update 时有可能会重建索引，所以视具体情况而定。一个表的索引数最好不要超过7个，若太多则应考虑一些不常使用到的列上建的索引是否有必要.\---\### 索引\- 索引是在存储引擎上实现的\- 为什么使用索引? \- 索引大大减少了存储引擎需要扫描的数据量 \- 索引可以帮助我们进行排序以避免使用临时表 \- 索引可以把随机I/O改为顺序I/O \- 索引不是越多越好 \- 索引会增加写操作的成本 \- 太多的索引会增加查询优化器的选择时间\#### 索引类型\##### B-Tree索引\- 特点 \- 能够中快数据的查询速度 \- 更适合进行范围查找\- 在什么情况下使用 \- 全值匹配的查询 \- 匹配最左前缀的查询 \- 匹配列前缀查询 \- 匹配范围值的查询 \- 精确匹配左前列并范围匹配别一列 \- 只访问索引的查询\- 使用限制 \- 如果不是按照索引最左列开始查找，则无法使用索引 \- 使用索引时不能跳过索引中的列 \- not in 和 &lt;&gt; 操作无法使用索引 \- 如果查询中有某个列的范围查询，则其所有的列都无法使用索引\##### Hash索引\- 特点 \- Hash索引是基于Hash表实现的，只有查询条件精确匹配Hash索引中的所有列时，才能使用到Hash索引 \- 对于Hash索引中的所有列，存储引擎都会为每一行计算一个Hash码，Hash索引中存储的就是Hash码 \- 两次查找\- 使用限制 \- Hash索引必须进行二次查找 \- Hash索引无法用于排序 \- Hash索引不支持部分索引查找也不支持范围查找\#### 建立索引的策略\- 索引列上不能使用表达式或函数\ /out_date为索引列/ select …… from product where to_days(out_date) - to_days(current_date) &lt; 30 select …… from product where out_date &lt;= date_add(current_date, interval 30 day) \123456\- 前缀索引和索引列的选择性 \- 索引的选择性是不重复的索引值的表的记录数的比值\ create index index_name on table(col_name(n)); \12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576\- 联合索引 \- 如何选择索引列的顺序​ \- 经常使用到的列优先​ \- 选择性高的列优先（过滤值多的）​ \- 宽度小的列优先​ \- 覆盖索引(直接在索引上获得数据，不读取数据行信息，where、分组、排序) \- 优点​ \- 可以优化缓存，减少磁盘I/O操作​ \- 可以减少随机I/O，变随机I/O操作变为顺序操作​ \- 可以避免对Innodb主键索引的二次查询​ \- 可以避免MyISAM表进行系统调用 \- 无法使用覆盖所引的情况​ \- 存储引擎不支持覆盖索引​ \- 查询中使用了太多的列​ \- 使用了双`%`号的like查询\#### 使用索引来优化查询\- 使用索引来优化排序 \- 通过排序操作 \- 按照索引顺序扫描数据​ \- 索引的列顺序和order by 子句的顺序完全一致​ \- 索引中所有的列的方向（升序、降序）和order by 子句完全一致​ \- order by 中的字段全部在关联表的中第一张表中\- 模拟Hash索引优化查询 \- 增加一个Hash列（md5) \- 只能处理键值的全值匹配查找 \- 所使用的Hash函数决定着索引键的大小\- 利用索引优化锁 \- 索引可以减少锁定的行数 \- 索引可以加快处理速度，同时也加快锁的释放\#### 索引的维护和优化\- 删除重复和冗余的索引\ primary ky (id), unique key (id) , index(id) –联合索引 index(a), index(a,b) –联合索引 primary key(id), index(a,id) \12345678910 \- 检查重复和冗余所引 pt-duplicate-key_checker h=127.0.01\- 查找未被使用过的索引\ 版本《=5.6 查找未被使用的索引： mysql&gt; select OBJECT_SCHEMA,OBJECT_NAME,INDEX_NAME, b.TABLE_ROWS from performance_schema.table_io_waits_summary_by_index_usage a join infomation_schema.tables b on a.OBJECT_SCHEMA = b.TABLE_SCHEMA and a.OBJECT_NAME = b.TABLE_NAME where INDEX_NAME is not null and COUNT_STAR=0 and OBJECT_SCHEMA=’xdq’ and OBJECT_NAME=’order_reasons_dispute’ order by OBJECT_SCHEMA,OBJECT_NAME; +—————+———————–+————+ | OBJECT_SCHEMA | OBJECT_NAME | INDEX_NAME | +—————+———————–+————+ | xdq | order_reasons_dispute | PRIMARY | | xdq | order_reasons_dispute | s_uid | | xdq | order_reasons_dispute | b_uid | | xdq | order_reasons_dispute | c_time | | xdq | order_reasons_dispute | r_time | +—————+———————–+————+ 5 rows in set (0.15 sec) 版本=5.7 mysql&gt; select * from sys.schema_redundant_indexes 冗余索引 mysql&gt; select * from schema_unused_indexes ; 未使用索引 –详见mysql5.7 sys schema视图详解 mysql&gt; select * from statements_with_full_table_scans; 使用全表扫描的sql语句 等 \123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354\- 更新索引统计信息及减少索引碎片 \- `annlyze table table_name` \- `optimize table table_name` 会锁表\#### 规范单个索引字段数不超过5，单表索引数量不超过5，索引设计遵循B+ Tree索引最左前缀匹配原则选择区分度高的列作为索引建立的索引能覆盖80%主要的查询，不求全，解决问题的主要矛盾DML和order by和group by字段要建立合适的索引避免索引的隐式转换避免冗余索引\#### 原则\1. 最左前缀匹配原则，非常重要的原则，MySQL会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。\2. =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，MySQL的查询优化器会帮你优化成索引可以识别的形式\3. 尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录\4. 索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);\5. 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可\---\### 锁机制\ # 查看当前运行的所有事务 select * from information_schema.innodb_trx; #查看正在锁的事务 SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS; #查看等待锁的事务 SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS; #查询结果为正在被锁状态的表 show OPEN TABLES where In_use &gt; 0; \123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370\---\### 事务\---\### 参数\#### innoDB数据库[参数说明](my-cnf-parameter.md)| 内存 | 1G | 2G | 4G | 8G | 16G | 32G | 64G | 72G | 96G | 128G || :------|:------: | :------: |:------:|:------: | :------: |:------:|:------: | :------: |:------:|:------: || innodb_buffer_pool_size | 128M | 768M | 2G | 4G | 10G | 18G | 38G | 48G | 48G | 72G || key_buffer_size | 8M | 16M | 32M | 32M | 64M | 64M | 64M | 64M | 64M | 64M || max_connections | 100 | 500 | 1000 | 2000 | 2000 | 2000 | 2000 | 500 | 5000 | 5000 || max_connect_errors | 100| 100| 100| 100| 100| 100| 100| 100| 100| 100|| innodb_file_per_table | 1| 1| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 || innodb_flush_method | O_DIRECT | O_DIRECT | O_DIRECT | O_DIRECT | O_DIRECT | O_DIRECT | O_DIRECT | O_DIRECT | O_DIRECT | O_DIRECT || innodb_log_file_size | 64M | 64M | 128M | 256M | 256M | 512M | 768M | 768M | 768M | 768M || innodb_log_buffer_size | 16M | 32M | 64M | 128M | 128M | 128M | 128M | 256M | 256M | 256M || innodb_flush_log_at_trx_commit | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 || innodb_doublewrite | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 || query_cache_size | 32M | 32M | 32M | 32M | 32M | 32M | 64M | 64M | 128M | 128M || log_bin | MySQL-bin| MySQL-bin| MySQL-bin| MySQL-bin| MySQL-bin| MySQL-bin| MySQL-bin| MySQL-bin| MySQL-bin| MySQL-bin|| skip_name_resolve | 开启 | 开启| 开启| 开启| 开启| 开启| 开启| 开启| 开启| 开启|| table_open_cache | | | | | | | | | | || max_allowed_packet | 32M | 32M | 32M | 32M | 32M | 32M | 32M | 32M | 32M | 32M || innodb_lock_wait_timeout | 60| 60| 60| 60| 60| 60| 60| 60| 60|60|\#### 可选参数| 内存 | 1G | 2G | 4G | 8G | 16G | 32G | 64G | 72G | 96G | 128G || :------|:------: | :------: |:------:|:------: | :------: |:------:|:------: | :------: |:------:|:------: || thread_stack | 256K | 256K | 256K | 256K | 256K | 256K | 512K | 512K |512K | 512K || sort_buffer_size | 256K | 256K | 512K | 512K | 1M | 1M | 2M | 2M |2M | 2M || read_buffer_size | 256K | 256K | 512K | 512K | 1M | 1M | 2M | 2M | 2M |2M || read_rnd_buffer_size | 256K | 512K | 512K | 1M | 1M | 2M | 2M | 2M | 2M | 2M || join_buffer_size | 256K |256K | 512K | 512K | 1M | 1M | 2M | 2M | 2M | 2M || binlog_cache_size | 64K | 64K | 64K | 64K | 64K | 64K | 128K | 128K |128K | 128K || max_binlog_size | 256M| 256M| 256M| 256M| 256M| 256M| 256M| 256M| 256M| 256M|| max_heap_table_size | 64M| 128M| 1G| 1G| 1G| 1G| 1G| 1G| 2G| 2G|| bulk_insert_buffer_size| 64M| 128M| 1G| 1G| 1G| 1G| 1G| 1G| 2G| 2G|| tmp_table_size | 64M| 128M| 1G| 1G| 1G| 1G| 1G| 1G| 2G| 2G|sysdate_is_now\#### 内存参数\- 确定可以可用的内存的上限\- 确定MYSQL的每个连接使用的内存\- 每个线程所需要的内存有​ * sort_buffer_size​ * read_buffer_size​ * read_rnd_buffer_size​ * join_buffer_sizeinnodb_buffer_pool_size = 总内存 - (每个线程所需要的内存*连接数) -系统保留内存key_buffer_size = select sum(index_lengh) from information_schema.tables where engine='myisam'\#### IO参数\- innodb ​ * innodb_log_file_size​ * innodb_log_files_in_group​ * 事务日志总大小 = innodb_log_file_size * innodb_log_files_in_group​ * innodb_log_buffer_size​ * innodb_flush_log_at_trx_commit​ * innodb_flush_method​ * innodb_file_per_table​ * innodb_doublewrite(对性能有影响，但不大，建议开启)\- MYISAM​ * delay_key_write\#### 安全参数 \- expire_logs_days 指定自动清理binlog的天数(兼容两次全备份的天数)\- max_allowed_packet 控制MySQL可以接收的包的大小\- skip_name_resolve 禁用DNS查找\- sysdate_is_now 确保sysdate()返回确定性天数\- read_only 禁止非super权限的用户写权限（主从在备库中用）\- skip_salve_start 禁用Slave自动恢复\- sql_mode 设备MySQL所使用的SQL模式（不要轻易改动生产环境下的sql_mode值）​ * strict_trans_tables​ * no_engine_subtitution​ * no_zero_date​ * no_zero_in_date​ * only_full_group_by​ * 其他...\#### 其他参数\- sync_binlog 控制MySQL如何向磁盘刷新binlog(主库中建议写成1)\- tmp_table_size 和 max_heap_table_size(一起使用) 控制内存临时表大小，值设置成一样\- max_connections 最大连接数\---\### 操作系统和硬件\---\### 应用系统\---\### 复制\---\### 架构\---\#### 可扩展\---\#### 高可用\---\### 备份与恢复\---\### mysql 监控\- 可用性监控 \- 确认网络连接​ \- mysqladmin -u(user)-p -h（ip） ping​ \- telnet ip db_port​ \- 使用程序通过网络建立数据库连接 \- 数据库是否可读写​ \- 检查数据库的read_only参数是否为off​ \- 建立监控表并对表中数据进行读写操作​ \- 执行简单的查询 select @@version \- 监控数据库的连接数​ \- show variables like 'max_connections';​ \- show global status like 'Threads_connected';​ \- Threads_connected / max_connections &gt; 0.8\- 性能监控 \- 记录性能监控过程中所采集到的数据库状态 \- 如何计算QPS和TPS​ \- show grobal status like 'queries' 和 show global status like 'uptime_since_flush_status'​ \- QPS = (queries2 - queries1) / (uptime_since_flush_status2 - uptime_since_flush_status1)​ \- TPS = ((Com_insert2 + Com_update2 + Com_delete2) - (Com_insert1 + Com_update1 + Com_delete1) ) / (Update_since_flush_status2 - Uptime_since_flush_status1) \- 如何监控数据库并发请求数据​ \- show global like 'Thread_running' ​ \- 数据库系统的性能会随着并发处理请求数据的增加而下降​ \- 并发处理的数据量通常会远小于同一时间连接到数据库的纯种的数量 \- 如何监控Innodb的阻塞​ \- 通过语句来查询（参考下面的语）\- 主从复制监控 \- 主从复制的链路状态​ \- Slave_IO_Running: Yes(出现非Yes就报警)​ \- Slave_SQL_Running: Yes(出现非Yes就报警) \- 主从复制延迟​ \- Seconds_behind_Master​ \- show master status \G​ \- show slave status \G​ \- 比较偏移量 \- 主从复制一致性​ \- pt-table-checksum\---\### 工具 \- oneproxy 分表分库 \- mycat \- maxscale \- pt-duplicate-key-checker #删除重复和冗余的索引 \- pt-query-digest #慢查询日志分析工具 \- mysqlbinlog #日志查看工具 \- pt-table-checksum\---\### 数据库性能优化常用sql脚本总结\1. 当前连接的Session 有多少\ SELECT login_name ​ ,[program_name] ​ ,COUNT(session_id) AS [session_count] FROM sys.dm_exec_sessions WITH (NOLOCK) GROUP BY login_name,[program_name] ORDER BY COUNT(session_id) desc; \12345678 \2. 每个数据库上的Session 数量是多少\ SELECT DB_NAME(dbid) AS DBName ​ ,COUNT(dbid) AS NumberOfConnections ​ ,loginame AS LoginName FROM sys.sysprocesses WHERE dbid &gt; 0 GROUP BY dbid,loginame \123456\3. 查看阻塞\ SELECT ​ SPID = er.session_id ​ ,STATUS = ses.STATUS ​ ,[LOGIN] = ses.login_name ​ ,HOST = ses.host_name ​ ,BlkBy = er.blocking_session_id ​ ,DBName = DB_NAME(er.database_id) ​ ,CommandType = er.command ​ ,SQLStatement = st.text ​ ,BlockingText = bst.text ​ ,ObjectName = OBJECT_NAME(st.objectid) ​ ,ElapsedMS = er.total_elapsed_time ​ ,CPUTime = er.cpu_time ​ ,IOReads = er.logical_reads + er.reads ​ ,IOWrites = er.writes ​ ,LastWaitType = er.last_wait_type ​ ,StartTime = er.start_time ​ ,Protocol = con.net_transport ​ ,ConnectionWrites = con.num_writes ​ ,ConnectionReads = con.num_reads ​ ,ClientAddress = con.client_net_address ​ ,Authentication = con.auth_scheme FROM sys.dm_exec_requests er OUTER APPLY sys.dm_exec_sql_text(er.sql_handle) st LEFT JOIN sys.dm_exec_sessions ses ON ses.session_id = er.session_id LEFT JOIN sys.dm_exec_connections con ON con.session_id = ses.session_id LEFT JOIN sys.dm_exec_requests ber ON er.blocking_session_id=ber.session_id OUTER APPLY sys.dm_exec_sql_text(ber.sql_handle) bst WHERE er.session_id &gt; 50 ORDER BY er.blocking_session_id DESC,er.session_id \123456 \4. 找出哪些表的Index 需要改进\ SELECT CONVERT(DECIMAL(18, 2), user_seeks avg_total_user_cost (avg_user_impact * 0.01)) AS [index_advantage] ​ ,migs.last_user_seek ​ ,mid.[statement] AS [Database.Schema.Table] ​ ,mid.equality_columns ​ ,mid.inequality_columns ​ ,mid.included_columns ​ ,migs.unique_compiles ​ ,migs.user_seeks ​ ,migs.avg_total_user_cost ​ ,migs.avg_user_impact FROM sys.dm_db_missing_index_group_stats AS migs WITH (NOLOCK) INNER JOIN sys.dm_db_missing_index_groups AS mig WITH (NOLOCK) ON migs.group_handle = mig.index_group_handle INNER JOIN sys.dm_db_missing_index_details AS mid WITH (NOLOCK) ON mig.index_handle = mid.index_handle ORDER BY index_advantage desc \12345678910 select object_schema, object_name, i\5. 查看Index 的Statistics 最后更新时间\ SELECT SCHEMA_NAME(o.[schema_id]) + N’.’ + o.[name] AS [Object Name] ​ ,o.type_desc AS [Object Type] ​ ,i.[name] AS [Index Name] ​ ,STATS_DATE(i.[object_id], i.index_id) AS [Statistics Date] ​ ,s.auto_created ​ ,s.no_recompute ​ ,s.user_created ​ ,st.row_count ​ ,st.used_page_count FROM sys.objects AS o WITH (NOLOCK) INNER JOIN sys.indexes AS i WITH (NOLOCK) ON o.[object_id] = i.[object_id]INNER JOIN sys.stats AS s WITH (NOLOCK) ON i.[object_id] = s.[object_id] ​ AND i.index_id = s.stats_id INNER JOIN sys.dm_db_partition_stats AS st WITH (NOLOCK) ON o.[object_id] = st.[object_id] ​ AND i.[index_id] = st.[index_id]WHERE o.[type] IN (‘U’,’V’) ​ AND st.row_count &gt; 0 ORDER BY STATS_DATE(i.[object_id], i.index_id) desc; \123456 \6. 查看Index 碎片化指数\ SELECT DB_NAME(ps.database_id) AS [Database Name] ​ ,OBJECT_NAME(ps.[object_id]) AS [Object Name] ​ ,i.[name] AS [Index Name] ​ ,ps.index_id ​ ,ps.index_type_desc ​ ,ps.avg_fragmentation_in_percent ​ ,ps.fragment_count ​ ,ps.page_count ​ ,i.fill_factor ​ ,i.has_filter ​ ,i.filter_definition FROM sys.dm_db_index_physical_stats(DB_ID(), NULL, NULL, NULL, N’LIMITED’) AS ps INNER JOIN sys.indexes AS i WITH (NOLOCK) ON ps.[object_id] = i.[object_id] ​ AND ps.index_id = i.index_id WHERE ps.database_id = DB_ID() ​ AND ps.page_count &gt; 2500 ORDER BY ps.avg_fragmentation_in_percent desc; \12345678 \7. 查询前 10 个可能是性能最差的 SQL 语句\ SELECT TOP 10 TEXT AS ‘SQL Statement’ ​ ,last_execution_time AS ‘Last Execution Time’ ​ ,(total_logical_reads + total_physical_reads + total_logical_writes) / execution_count AS [Average IO] ​ ,(total_worker_time / execution_count) / 1000000.0 AS [Average CPU Time (sec)] ​ ,(total_elapsed_time / execution_count) / 1000000.0 AS [Average Elapsed Time (sec)] ​ ,execution_count AS “Execution Count” ​ ,qp.query_plan AS “Query Plan” FROM sys.dm_exec_query_stats qs CROSS APPLY sys.dm_exec_sql_text(qs.plan_handle) st CROSS APPLY sys.dm_exec_query_plan(qs.plan_handle) qp ORDER BY total_elapsed_time / execution_count DESC \12345678\8. 查询Innode阻塞\ select b.trx_mysql_thread_id as 被阻塞线程 ,b.trx_query as 被阻塞SQL ,c.trx_mysql_thread_id as 阻塞线程 ,c.trx_query as 阻塞SQL ,(UNIX_TIMESTAMP() - UNIX_TIMESTAMP(c.trx_started)) as 阻塞时间 from information_schema.innodb_lock_waits a join information_schema.innodb_trx b on a.requesting_trx_id=b.trx_id join information_schema.innodb_trx c on a.blocking_trx_id=c.trx_id where (UNIX_TIMESTAMP() - UNIX_TIMESTAMP(c.trx_started))&gt; 10 ` ### 参考 - https://segmentfault.com/a/1190000004946420#articleHeader2 - http://www.cnblogs.com/rollenholt/p/3776923.html - 《打造扛得住的MySQL数据库架构》]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cordova 命令]]></title>
    <url>%2F2018%2F09%2F09%2Fcordova%2F</url>
    <content type="text"><![CDATA[cordova命令安装cordova，必须先安装node.js windows: npm install -g cordova ios &amp; linux: sudo npm install -g cordova Create the App: cordova create DirectoryName com.package.name ProjectName Add/Remove/ls Platforms: cd DirectoryName cordova platform add android cordova platform add ios cordova platform add amazon-fireos cordova platform add blackberry10 cordova platform add firefoxos cordova platforms ls cordova platform rm android Build the App: cordova build cordova build ios cordova prepare ios cordova compile ios Test the App on an Emulator or Device: cordova emulate android cordova run android Add Plugin Features: cordova plugin add org.apache.cordova.device cordova plugin add org.apache.cordova.network-information cordova plugin add org.apache.cordova.battery-status cordova plugin add org.apache.cordova.device-motion cordova plugin add org.apache.cordova.device-orientation cordova plugin add org.apache.cordova.geolocation cordova plugin add org.apache.cordova.camera cordova plugin add org.apache.cordova.media-capture cordova plugin add org.apache.cordova.media cordova plugin add org.apache.cordova.file cordova plugin add org.apache.cordova.file-transfer cordova plugin add org.apache.cordova.dialogs cordova plugin add org.apache.cordova.vibration cordova plugin add org.apache.cordova.contacts cordova plugin add org.apache.cordova.globalization cordova plugin add org.apache.cordova.splashscreen cordova plugin add org.apache.cordova.inappbrowser cordova plugin add org.apache.cordova.console cordova plugin ls cordova plugin rm org.apache.cordova.console —or— cordova plugin remove org.apache.cordova.console Help Commands: cordova help —or— cordova cordova info Updating Cordova and Your Project: cordova -v sudo npm update -g cordova npm info cordova cordova platform update android cordova platform update ios …etc. npm install -g ionic cordova@6.0.0]]></content>
      <categories>
        <category>cordova</category>
      </categories>
      <tags>
        <tag>cordova 命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE 基础]]></title>
    <url>%2F2018%2F09%2F03%2Fvue%2F</url>
    <content type="text"><![CDATA[VUE全家桶GIT地址：https://gitee.com/plusdo/vue-demo Vue 前后端分离 使用Vue的好处 数据架构 技术栈 ES2015 Promise Vue 2.0 https://cn.vuejs.org/index.html vue-router：处理路由 https://router.vuejs.org/zh-cn/ vuex：处理单项数据绑定 https://vuex.vuejs.org/zh-cn/ axios：处理向后端的http资源请求 https://github.com/axios/axios https://ykloveyxk.github.io/2017/02/25/axios%E5%85%A8%E6%94%BB%E7%95%A5/ element-ui：基于vue2.0 的组件库，饿了么的这套组件库还挺好用的，功能也全 https://element.eleme.io/#/zh-CN mint-ui：移动端UI https://mint-ui.github.io/#!/zh-cn sass：专业级CSS扩展语言 https://www.sass.hk/ Flex: Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 教程1：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html 教程2：http://blog.csdn.net/qq_23191031/article/details/53084017 jwt后台验证，通过vue-router和axios统一处理认证问题 图标库 http://www.iconfont.cn/home/index?spm=a313x.7781069.1998910419.2 其他组件 better-scroll：处理页面滚动操作。 moment.js：处理时间。 vue-core-image-upload：处理附件上传。 vuex-persistedstate：vuex插件，处理页面刷新时store中的内容丢失的问题，将store存储在localstorage中 调试工具 Chrome Vue.js devtools: Chrome插件，查看vuex状态 console 参考项目可以参考代码进行练习： https://github.com/bxm0927/vue-meituan https://github.com/hzzly/xyy-vue 开发工具统一使用vsCode进行开发，安装EditorConfig for VS Code插件处理缩进等问题。 接口工具接口工具统一使用 RAP，提供接口功能和mock服务。 后台登录地址：http://server-ip/serverName/rest/login(post)，请求 传入参数格式{&quot;username&quot;:&quot;admin&quot;, &quot;password&quot;:&quot;000000&quot;}，登录成功后将返回的token写入localstorage中 其他请求需要将token写入http的header中的Authorization(自定义)字段,有src/api/api.js统一完成。 安装及运行123456789101112131415161718192021222324252627# vue-cli# 全局安装 vue-cli$ npm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project# 安装依赖，走你$ cd my-project# 安装node-sassnpm install node-sass# 安装依赖npm install# serve with hot reload at localhost:8080# 调试运行，默认启动8080端口npm run dev# build for production with minification# 编译打包npm run build# build for production and view the bundle analyzer reportnpm run build --report# 修复npm安装时报VCBuild不存在的错误, 使用npm安装windows build toolsnpm install --global --production windows-build-tools 目录结构123456789101112131415161718192021222324252627282930313233343536373839404142434445|-- build // 项目构建(webpack)相关代码| |-- build.js // 生产环境构建代码| |-- check-version.js // 检查node、npm等版本| |-- dev-client.js // 热重载相关| |-- dev-server.js // 构建本地服务器| |-- utils.js // 构建工具相关| |-- webpack.base.conf.js // webpack基础配置| |-- webpack.dev.conf.js // webpack开发环境配置| |-- webpack.prod.conf.js // webpack生产环境配置|-- config // 项目开发环境配置| |-- dev.env.js // 开发环境变量| |-- index.js // 项目一些配置变量| |-- prod.env.js // 生产环境变量|-- src // 源码目录| |-- api // 统一处理资源请求| | |-- http.js // 处理api服务路径及token拦截功能| | |-- api.js // 处理业务api服务路径| |-- assets // 资源目录，图片/javascript/css| |-- components // vue公共组件| | |-- base // 页面基本布局组件| |-- config // 项目参数配置| |-- pages // 项目页面，所有项目的页面均放本目录| | |-- logistics // 物流页面| | |-- error // 错误页面| | |-- login // 登录页面| | |-- member // 会员管理页面| | |-- sale // 销售页面| |-- router // 路由配置文件，所有请求跳转配置| |-- store // vuex的状态管理，单向数据绑定，所有数据状态都存在此处| | |-- modules // 业务模块状态管理| | |-- actions.js // 公共action| | |-- getters.js // 公共getter| | |-- index.js // vuex统一管理页面，引用 mutations、actions、getters等| | |-- mutation-types.js // mutation类型| | |-- mutations.js // 公共mutatios| |-- App.vue // 页面入口文件| |-- main.js // 程序入口文件，加载各种公共组件|-- static // 静态文件，比如一些图片，json数据等|-- .babelrc // ES6语法编译配置|-- .editorconfig // 定义代码格式|-- .gitignore // git上传需要忽略的文件格式|-- README.md // 项目说明|-- favicon.ico // 图标|-- index.html // 首页入口文件，你可以添加一些 meta 信息或同统计代码啥的。|-- package.json // 项目基本信息 开发常见问题 路径带#的问题 vue-router 拦截的问题 axios 拦截的问题 axios 跨域访问问题 变量处理的问题 图片加载的问题 require props computed watch 自定义组件传值问题 打包时包过大的问题 样式 scope vue-router 嵌套 ​]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux]]></title>
    <url>%2F2018%2F08%2F28%2Flinux%2F</url>
    <content type="text"><![CDATA[LINUX系统信息arch 显示机器的处理器架构(1) uname -m 显示机器的处理器架构(2) uname -r 显示正在使用的内核版本 dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI) hdparm -i /dev/hda 罗列一个磁盘的架构特性 hdparm -tT /dev/sda 在磁盘上执行测试性读取操作 cat /proc/cpuinfo 显示CPU info的信息 cat /proc/interrupts 显示中断 cat /proc/meminfo 校验内存使用 cat /proc/swaps 显示哪些swap被使用 cat /proc/version 显示内核的版本 cat /proc/net/dev 显示网络适配器及统计 cat /proc/mounts 显示已加载的文件系统 lspci -tv 罗列 PCI 设备 lsusb -tv 显示 USB 设备 date 显示系统日期 cal 2007 显示2007年的日历表 date 041217002007.00 设置日期和时间 - 月日时分年.秒 clock -w 将时间修改保存到 BIOS 关机 (系统的关机、重启以及登出 )shutdown -h now 关闭系统(1) init 0 关闭系统(2) telinit 0 关闭系统(3) shutdown -h hours:minutes &amp; 按预定时间关闭系统 shutdown -c 取消按预定时间关闭系统 shutdown -r now 重启(1) reboot 重启(2) logout 注销 文件和目录cd /home 进入 ‘/ home’ 目录’ cd .. 返回上一级目录 cd ../.. 返回上两级目录 cd 进入个人的主目录 cd ~user1 进入个人的主目录 cd - 返回上次所在的目录 pwd 显示工作路径 ls 查看目录中的文件 ls -F 查看目录中的文件 ls -l 显示文件和目录的详细资料 ls -a 显示隐藏文件 ls [0-9] 显示包含数字的文件名和目录名 tree 显示文件和目录由根目录开始的树形结构(1) lstree 显示文件和目录由根目录开始的树形结构(2) mkdir dir1 创建一个叫做 ‘dir1’ 的目录’ mkdir dir1 dir2 同时创建两个目录 mkdir -p /tmp/dir1/dir2 创建一个目录树 rm -f file1 删除一个叫做 ‘file1’ 的文件’ rmdir dir1 删除一个叫做 ‘dir1’ 的目录’ rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容 rm -rf dir1 dir2 同时删除两个目录及它们的内容 mv dir1 new_dir 重命名/移动 一个目录 cp file1 file2 复制一个文件 cp dir/* . 复制一个目录下的所有文件到当前工作目录 cp -a /tmp/dir1 . 复制一个目录到当前工作目录 cp -a dir1 dir2 复制一个目录 ln -s file1 lnk1 创建一个指向文件或目录的软链接 ln file1 lnk1 创建一个指向文件或目录的物理链接 touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm) file file1 outputs the mime type of the file as text iconv -l 列出已知的编码 iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding. find . -maxdepth 1 -name *.jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” \; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick) 文件搜索find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录 find / -user user1 搜索属于用户 ‘user1’ 的文件和目录 find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件 find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件 find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 find / -name *.rpm -exec chmod 755 ‘{}’ \; 搜索以 ‘.rpm’ 结尾的文件并定义其权限 find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备 locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令 whereis halt 显示一个二进制文件、源码或man的位置 which halt 显示一个二进制文件或可执行文件的完整路径 挂载一个文件系统mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在 umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出 fuser -km /mnt/hda2 当设备繁忙时强制卸载 umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用 mount /dev/fd0 /mnt/floppy 挂载一个软盘 mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件 mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统 mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备 mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享 磁盘空间df -h 显示已经挂载的分区列表 ls -lSr |more 以尺寸大小排列文件和目录 du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’ du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小 rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统) dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统) 用户和群组groupadd group_name 创建一个新用户组 groupdel group_name 删除一个用户组 groupmod -n new_group_name old_group_name 重命名一个用户组 useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户 useradd user1 创建一个新用户 userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录) usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性 passwd 修改口令 passwd user1 修改一个用户的口令 (只允许root执行) chage -E 2005-12-31 user1 设置用户口令的失效期限 pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户 grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组 newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组 文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消ls -lh 显示权限 ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示 chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限 chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限 chown user1 file1 改变一个文件的所有人属性 chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性 chgrp group1 file1 改变文件的群组 chown user1:group1 file1 改变一个文件的所有人和群组属性 find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件 chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限 chmod u-s /bin/file1 禁用一个二进制文件的 SUID位 chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的 chmod g-s /home/public 禁用一个目录的 SGID 位 chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件 chmod o-t /home/public 禁用一个目录的 STIKY 位 文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消chattr +a file1 只允许以追加方式读写文件 chattr +c file1 允许这个文件能被内核自动压缩/解压 chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件 chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接 chattr +s file1 允许一个文件被安全地删除 chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘 chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件 lsattr 显示特殊的属性 打包和压缩文件bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件 bzip2 file1 压缩一个叫做 ‘file1’ 的文件 gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件 gzip file1 压缩一个叫做 ‘file1’的文件 gzip -9 file1 最大程度压缩 rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包 rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’ rar x file1.rar 解压rar包 unrar x file1.rar 解压rar包 tar -cvf archive.tar file1 创建一个非压缩的 tarball tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件 tar -tf archive.tar 显示一个包中的内容 tar -xvf archive.tar 释放一个包 tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下 tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包 tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包 tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包 tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包 zip file1.zip file1 创建一个zip格式的压缩包 zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 unzip file1.zip 解压一个zip格式压缩包 RPM 包 - （Fedora, Redhat及类似系统）rpm -ivh package.rpm 安装一个rpm包 rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告 rpm -U package.rpm 更新一个rpm包但不改变其配置文件 rpm -F package.rpm 更新一个确定已经安装的rpm包 rpm -e package_name.rpm 删除一个rpm包 rpm -qa 显示系统中所有已经安装的rpm包 rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包 rpm -qi package_name 获取一个已安装包的特殊信息 rpm -qg “System Environment/Daemons” 显示一个组件的rpm包 rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表 rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表 rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表 rpm -q package_name –whatprovides 显示一个rpm包所占的体积 rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本l rpm -q package_name –changelog 显示一个rpm包的修改历史 rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供 rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表 rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书 rpm –checksig package.rpm 确认一个rpm包的完整性 rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性 rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间 rpm -Va 检查系统中所有已安装的rpm包- 小心使用 rpm -Vp package.rpm 确认一个rpm包还未安装 rpm2cpio package.rpm | cpio –extract –make-directories bin 从一个rpm包运行可执行文件 rpm -ivh /usr/src/redhat/RPMS/arch/package.rpm 从一个rpm源码安装一个构建好的包 rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包 YUM 软件包升级器 - （Fedora, RedHat及类似系统）yum install package_name 下载并安装一个rpm包 yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系 yum update package_name.rpm 更新当前系统中所有安装的rpm包 yum update package_name 更新一个rpm包 yum remove package_name 删除一个rpm包 yum list 列出当前系统中安装的所有包 yum search package_name 在rpm仓库中搜寻软件包 yum clean packages 清理rpm缓存删除下载的包 yum clean headers 删除所有头文件 yum clean all 删除所有缓存的包和头文件 DEB 包 (Debian, Ubuntu 以及类似系统)dpkg -i package.deb 安装/更新一个 deb 包 dpkg -r package_name 从系统删除一个 deb 包 dpkg -l 显示系统中所有已经安装的 deb 包 dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包 dpkg -s package_name 获得已经安装在系统中一个特殊包的信息 dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表 dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表 dpkg -S /bin/ping 确认所给的文件由哪个deb包提供 APT 软件工具 (Debian, Ubuntu 以及类似系统)apt-get install package_name 安装/更新一个 deb 包 apt-cdrom install package_name 从光盘安装/更新一个 deb 包 apt-get update 升级列表中的软件包 apt-get upgrade 升级所有已安装的软件 apt-get remove package_name 从系统删除一个deb包 apt-get check 确认依赖的软件仓库正确 apt-get clean 从下载的软件包中清理缓存 apt-cache search searched-package 返回包含所要搜索字符串的软件包名称 查看文件内容cat file1 从第一个字节开始正向查看文件的内容 tac file1 从最后一行开始反向查看一个文件的内容 more file1 查看一个长文件的内容 less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作 head -2 file1 查看一个文件的前两行 tail -2 file1 查看一个文件的最后两行 tail -f /var/log/messages 实时查看被添加到一个文件中的内容 文本处理cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中 cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中 grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug” grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇 grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行 grep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug” sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2” sed ‘/^$/d’ example.txt 从example.txt文件中删除所有空白行 sed ‘/ *#/d; /^$/d’ example.txt 从example.txt文件中删除所有注释和空白行 echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容 sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行 sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行 sed -e ‘s/ *$//‘ example.txt 删除每一行最后的空白字符 sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部 sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容 sed -n ‘5p;5q’ example.txt 查看第5行 sed -e ‘s/00*/0/g’ example.txt 用单个零替换多个零 cat -n file1 标示文件的行数 cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行 echo a b c | awk ‘{print $1}’ 查看一行第一栏 echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏 paste file1 file2 合并两个文件或两栏的内容 paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分 sort file1 file2 排序两个文件的内容 sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份) sort file1 file2 | uniq -u 删除交集，留下其他的行 sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件) comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容 comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容 comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分 字符设置和文件格式转换dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html recode -l | more 显示所有允许的转换格式 文件系统分析badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块 fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性 fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性 e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性 fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性 fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性 初始化一个文件系统mkfs /dev/hda1 在hda1分区创建一个文件系统 mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统 mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统 mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统 fdformat -n /dev/fd0 格式化一个软盘 mkswap /dev/hda3 创建一个swap文件系统 SWAP文件系统mkswap /dev/hda3 创建一个swap文件系统 swapon /dev/hda3 启用一个新的swap文件系统 swapon /dev/hda2 /dev/hdb3 启用两个swap分区 备份dump -0aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的完整备份 dump -1aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的交互式备份 restore -if /tmp/home0.bak 还原一个交互式备份 rsync -rogpav –delete /home /tmp 同步两边的目录 rsync -rogpav -e ssh –delete /home ip_address:/tmp 通过SSH通道rsync rsync -az -e ssh –delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录 rsync -az -e ssh –delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录 dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr ‘dd of=hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作 dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件 tar -Puf backup.tar /home/user 执行一次对 ‘/home/user’ 目录的交互式备份操作 ( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容 ( tar c /home ) | ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录 tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接 find /home/user1 -name ‘*.txt’ | xargs cp -av –target-directory=/home/backup/ –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录 find /var/log -name ‘*.log’ | tar cv –files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包 dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作 dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容 光盘cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容 mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件 mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件 mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件 cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件 gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件 mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件 cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中 cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3） cdrecord –scanbus 扫描总线以识别scsi通道 dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD 网络 - （以太网和WIFI无线）ifconfig eth0 显示一个以太网卡的配置 ifup eth0 启用一个 ‘eth0’ 网络设备 ifdown eth0 禁用一个 ‘eth0’ 网络设备 ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址 ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing) dhclient eth0 以dhcp模式启用 ‘eth0’ route -n show routing table route add -net 0/0 gw IP_Gateway configura default gateway route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network ‘192.168.0.0/16’ route del 0/0 gw IP_gateway remove static route echo “1” &gt; /proc/sys/net/ipv4/ip_forward activate ip routing hostname show hostname of system host www.example.com lookup hostname to resolve name to ip address and viceversa(1) nslookup www.example.com lookup hostname to resolve name to ip address and viceversa(2) ip link show show link status of all interfaces mii-tool eth0 show link status of ‘eth0’ ethtool eth0 show statistics of network card ‘eth0’ netstat -tup show all active network connections and their PID netstat -tupl show all network services listening on the system and their PID tcpdump tcp port 80 show all HTTP traffic iwlist scan show wireless networks iwconfig eth1 show configuration of a wireless network card hostname show hostname host www.example.com lookup hostname to resolve name to ip address and viceversa nslookup www.example.com lookup hostname to resolve name to ip address and viceversa whois www.example.com lookup on Whois database JPS工具jps(Java Virtual Machine Process Status Tool)是JDK 1.5提供的一个显示当前所有java进程pid的命令，简单实用，非常适合在linux/unix平台上简单察看当前java进程的一些简单情况。 ​ 我想很多人都是用过unix系统里的ps命令，这个命令主要是用来显示当前系统的进程情况，有哪些进程，及其 id。 jps 也是一样，它的作用是显示当前系统的java进程情况，及其id号。我们可以通过它来查看我们到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例），和他们的进程号（为下面几个程序做准备），并可通过opt来查看这些进程的详细启动参数。 ​ 使用方法：在当前命令行下打 jps(需要JAVA_HOME，没有的话，到改程序的目录下打) 。 jps存放在JAVA_HOME/bin/jps，使用时为了方便请将JAVA_HOME/bin/加入到Path. $&gt; jps 23991 Jps 23789 BossMain 23651 Resin 比较常用的参数： -q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数 $&gt; jps -q 28680 23789 23651 -m 输出传递给main 方法的参数，在嵌入式jvm上可能是null $&gt; jps -m 28715 Jps -m 23789 BossMain 23651 Resin -socketwait 32768 -stdout /data/aoxj/resin/log/stdout.log -stderr /data/aoxj/resin/log/stderr.log -l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名 $&gt; jps -l 28729 sun.tools.jps.Jps 23789 com.asiainfo.aimc.bossbi.BossMain 23651 com.caucho.server.resin.Resin -v 输出传递给JVM的参数 $&gt; jps -v 23789 BossMain 28802 Jps -Denv.class.path=/data/aoxj/bossbi/twsecurity/java/trustwork140.jar:/data/aoxj/bossbi/twsecurity/java/:/data/aoxj/bossbi/twsecurity/java/twcmcc.jar:/data/aoxj/jdk15/lib/rt.jar:/data/aoxj/jd k15/lib/tools.jar -Dapplication.home=/data/aoxj/jdk15 -Xms8m 23651 Resin -Xss1m -Dresin.home=/data/aoxj/resin -Dserver.root=/data/aoxj/resin -Djava.util.logging.manager=com.caucho.log.LogManagerImpl - Djavax.management.builder.initial=com.caucho.jmx.MBeanServerBuilderImpl sudo jps看到的进程数量最全 jps 192.168.0.77 列出远程服务器192.168.0.77机器所有的jvm实例，采用rmi协议，默认连接端口为1099 （前提是远程服务器提供jstatd服务） 注：jps命令有个地方很不好，似乎只能显示当前用户的java进程，要显示其他用户的还是只能用unix/linux的ps命令。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http状态码]]></title>
    <url>%2F2018%2F06%2F16%2Fhttp%2F</url>
    <content type="text"><![CDATA[HTTP状态码 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务） 204 NO CONTENT - [DELETE]：用户删除数据成功。 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。]]></content>
      <categories>
        <category>数据传输</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
</search>
